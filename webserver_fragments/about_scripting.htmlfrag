
<br/>

<h2>Winter Scripting</h2>

<p>Most scripting in the Substrata metaverse is currently done with the <a href="https://github.com/glaretechnologies/winter">Winter programming language</a>.
</p>

<p>Winter is a high-performance functional programming language, made by us at Glare Technologies.  We use it in our other software <a href="https://www.indigorenderer.com/">Indigo Renderer</a> and 
<a href="https://www.chaoticafractals.com/">Chaotica</a>.
</p>


<h3>Winter Language reference</h3>
<p>See the <a href="https://github.com/glaretechnologies/winter">Github Winter page</a> for the language reference documentation.
</p>

<h3>Client-side execution</h3>
<p>Scripts in Substrata are executed in the Substrata client program (e.g. they are executed 'client-side').  
Winter programs are restricted in what they can do, so are safe to execute client-side.  
(Although we can't rule out all bugs in the Winter execution environment)</p><h3>Scripting an object</h3><p>To make a script for an object, you edit code in the 'Script' text edit box in the object editor in the Substrata client, 
after selecting an object.   
You can only edit scripts on objects that you own (e.g. that you created).</p>

<h3>Scriptable functions</h3>
<p>To script the behaviour of an object, you can define either of two functions:</p><h4>evalRotation</h4><code>def evalRotation(float time, WinterEnv env) vec3</code><p>time is the
current global time in the Substrata metaverse.
</p>
<p>This function returns a 3-vector, where the direction of the vector defines the axis of rotation, and the length of the vector defines the counter-clockwise rotation around the axis, in radians.
</p>
<p>
For example, the rotating wind turbine blades use the following script:<p><code>def evalRotation(float time, WinterEnv env) vec3 : vec3(-0.6, 0.0, 0.0) * time</code>

<p>This rotates the blades clockwise (due to the minus sign) around the x axis at a constant rate.</p><h4>evalTranslation</h4><code>def evalTranslation(float time, WinterEnv env) vec3</code><p>This function returns a 3-vector, 
which defines a spatial translation from the usual position of an object (as placed by a user or entered in the object editor).  
The translation can be a function of time  to allow object movement.</p><p>For example, this script makes an object move back and forth along the x axis by a total of 1.6 metres:
</p>

<p>
<code>def evalTranslation(float time, WinterEnv env) vec3 : vec3(sin(time * 1.5) * 0.8, 0, 0)</code>
</p>

<br/>
<hr/>
<br/>

<h2>XML Scripting: Follow Path Script</h2>

<p>You can also use XML to define some behaviours for an object, for example make the object follow a path around the world.  (This is the kind of script that the monorail uses)</p>
<p>
The following is a script that makes an object continuously follow a square shaped path:
</p>

<code>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;script&gt;
	&lt;follow_path&gt;
		&lt;speed&gt;3&lt;/speed&gt;

		&lt;waypoint&gt;&lt;pos&gt;0 0 1&lt;/pos&gt;	&lt;type&gt;Stop&lt;/type&gt;	&lt;pause_time&gt;1&lt;/pause_time&gt;	&lt;/waypoint&gt;
		&lt;waypoint&gt;&lt;pos&gt;10 0 1&lt;/pos&gt;	&lt;type&gt;Stop&lt;/type&gt;	&lt;pause_time&gt;1&lt;/pause_time&gt;	&lt;/waypoint&gt;
		&lt;waypoint&gt;&lt;pos&gt;10 10 1&lt;/pos&gt;	&lt;type&gt;Stop&lt;/type&gt;	&lt;pause_time&gt;1&lt;/pause_time&gt;	&lt;/waypoint&gt;
		&lt;waypoint&gt;&lt;pos&gt;0 10 1&lt;/pos&gt;	&lt;type&gt;Stop&lt;/type&gt;	&lt;pause_time&gt;1&lt;/pause_time&gt;	&lt;/waypoint&gt;
	&lt;/follow_path&gt;
&lt;/script&gt;
</pre>
</code>

<p>Each waypoint has the position of the waypoint, what type of waypoint it is, and in the case of 'Stop' waypoints, how long the object will stop at the waypoint before continuing.
</p>

<p>The &lt;speed&gt;3&lt;/speed&gt; tag also sets the default speed of the object along the path, although this can be overridden for each waypoint.
</p>

<br/>
<hr/>
<br/>

<h2>Hovercar</h2>

<p>This is an XML script, that allows any object in the world to behave like a hovercar, that can be entered and driven by a user.</p>
<code>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;script&gt;
	&lt;hover_car&gt; 
		&lt;model_to_y_forwards_rot_1&gt;1.57079632679 0 0&lt;/model_to_y_forwards_rot_1&gt;
		&lt;model_to_y_forwards_rot_2&gt;0 0 3.141592653&lt;/model_to_y_forwards_rot_2&gt;

		&lt;seat&gt;
			&lt;seat_position&gt;0.45 0.43 -0.2&lt;/seat_position&gt;
			&lt;upper_body_rot_angle&gt;0.2&lt;/upper_body_rot_angle&gt;
			&lt;upper_leg_rot_angle&gt;1.9&lt;/upper_leg_rot_angle&gt;
			&lt;lower_leg_rot_angle&gt;-0.5&lt;/lower_leg_rot_angle&gt;
		&lt;/seat&gt;

		&lt;seat&gt;
			&lt;seat_position&gt;-0.45 0.43 -0.2&lt;/seat_position&gt;
			&lt;upper_body_rot_angle&gt;0.2&lt;/upper_body_rot_angle&gt;
			&lt;upper_leg_rot_angle&gt;1.9&lt;/upper_leg_rot_angle&gt;
			&lt;lower_leg_rot_angle&gt;-0.5&lt;/lower_leg_rot_angle&gt;
		&lt;/seat&gt;
	&lt;/hover_car&gt;
&lt;/script&gt;		
</pre>
</code>

<p>First off we have two rotations that allow transforming from the model to world space.   This is useful in cases like transforming from GLTF coordinates (y-up) to Substrata coordinates (z-up).</p>
<p><b>model_to_y_forwards_rot_1</b>:  This is an axis-angle rotation, from model coordinates (object space) to world coordinates (y-forwards space). (before overall transformation of hovercar)</p>
<p>The world coordinates have the following convention: the z-axis is up, the x-axis is right, and the y-axis is forwards.</p>
<p>The length of the model_to_y_forwards_rot_1 vector is the angle of rotation in radians, counterclockwise around the vector.</p>

<p>In the example above we rotate around the x axis by 90 degrees, to transform from y-up to z-up.</p>

<p><b>model_to_y_forwards_rot_2</b> allows defining a second rotation.  In the example above the second rotation rotates around the z-axis by 180 degrees (pi radians).</p>

<p>The overall rotation is given by model_to_y_forwards_rot_2 * model_to_y_forwards_rot_1.  This means the model_to_y_forwards_rot_1 rotation is applied first, then model_to_y_forwards_rot_2</p>

<h3>Seats</h3>

<p>Each vehicle can have one or more seats.  The first seat is the driver's seat.  Seats are defined with the following XML elements:</p>

<p><b>seat_position</b>:  This is the position in model coordinates where the hip bone of the avatar should be placed.  You can get the position by opening the model in Blender, just
be aware that the Blender GLTF importer changes the coordinate space from y-up of GLTF to z-up upon import.</p>

<p><b>upper_body_rot_angle</b>: This is the rotation, in radians, of the upper body, from the default vertical orientation.  A positive angle means the avatar will lean back.</p>

<p><b>upper_leg_rot_angle</b>: This is the rotation, in radians, of the leg around the hip joint, from the default vertical orientation.  
A positive angle means the upper leg will rotate forwards toward the chest.
</p>

<p><b>lower_leg_rot_angle</b>: This is the rotation, in radians, of the lower leg around the knee joint.
A negative angle means the lower leg will rotate backwards toward the heel.
</p>

<h3>Applying the hovercar script</h3>

<p>You can just copy and paste the above example script into the script field of an object, however there are some requirements:</p>

<ul>
<li>The object will need to be an object you have write permissions for (e.g. that you own).  The easiest way to have an object you own is to create it on a parcel you own, or to create it
in your personal world.
</li>

<li>You will need to set an appropriate mass (in kg) of your object in the object editor - too small and wind resistance will slow the object too much, as thrust force is proportional to object mass.
</li>

<li>You will need to check the <b>dynamic</b> checkbox in the object editor to make the object into a simulated physics object that can move.</li>
</ul>





<br/>
<hr/>
<br/>

<h2 id="dynamic-texture-updating">Dynamic Texture Updating</h2>


<p>This is an XML script that allows image textures on objects in the world to be updated occasionally from an external web server.</p>

<p>In the example script below, the URL https://images.metaverse-billboards.com/space1.png is periodically checked for a new image.</p>

<code>
<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;script&gt;
	&lt;dynamic_texture_update&gt;
		&lt;base_url&gt;https://images.metaverse-billboards.com/space1.png&lt;/base_url&gt;
		&lt;material_index&gt;0&lt;/material_index&gt; &lt;!-- optional --&gt;
		&lt;material_texture&gt;colour&lt;/material_texture&gt; &lt;!-- optional, can be 'colour' or 'emission' --&gt;
	&lt;/dynamic_texture_update&gt;
&lt;/script&gt;
</pre>
</code>

	<p>
		To make an object with a dynamically updating texture:
		From the Substrata client, add an image object in the usual way: 'Add Model/Image/Video' toolbar button, then select 'from disk' tab and select a placeholder image.
		Then edit the script field to add the script above.
	</p>
	<p>
		Your user account needs to be whitelisted by a Substrata admin for this script to work.
		Message @nick on our Discord server, or contact us at contact@glaretechnologies.com to request this.
	</p>
	<p>
		Images are checked from the URL given by 'base_url' for updates approximately every hour.  If an updated image is returned by the webserver, then the updated image will be inserted into Substrata
as a resource, and the updated image will be applied to the object.
	</p>


	<br/>
<hr/>
<br/>

<h2>Future Scripting</h2>
<p>We may allow server-side scripting in the future, using a language like Javascript, and with some way of maintaining state.
</p>
<p>
We plan to allow users to run their own server as well, to control their parcels, which will allow arbitrarily complicated code to affect their Substrata parcels.
</p>

<br/><br/>

<a href="/">&lt; Home</a>																			
